import argparse
import pandas as pd
import matplotlib.pyplot as plt
from io import StringIO
from itertools import combinations
from typing import Optional, List, Tuple, Dict


class EntryPoint:

    PROG = 'python differential_conservation_score.py'

    DESCRIPTION = 'Differential conservation score by Yu-Cheng Lin (ylin@nycu.edu.tw)'

    ARGS = [
        {
            'keys': ['-f', '--aligned-faa'],
            'properties': {
                'type': str,
                'required': True,
                'help': 'path to fasta file generated by multiple sequence alignment',
            }
        },
        {
            'keys': ['-1', '--prefix-1'],
            'properties': {
                'type': str,
                'required': True,
                'help': 'fasta header prefix for group 1 proteins',
            }
        },
        {
            'keys': ['-2', '--prefix-2'],
            'properties': {
                'type': str,
                'required': True,
                'help': 'fasta header prefix for group 2 proteins',
            }
        },
        {
            'keys': ['-c', '--fraction-cutoff'],
            'properties': {
                'type': float,
                'required': False,
                'default': 0.5,
                'help': 'fraction cutoff for aminoacid present at each position (default: %(default)s)',
            }
        },
        {
            'keys': ['-h', '--help'],
            'properties': {
                'action': 'help',
                'help': 'show this help message',
            }
        },
    ]

    parser: argparse.ArgumentParser

    def main(self):
        self.set_parser()
        self.add_args()
        self.run()

    def set_parser(self):
        self.parser = argparse.ArgumentParser(
            prog=self.PROG,
            description=self.DESCRIPTION,
            add_help=False,
            formatter_class=argparse.RawTextHelpFormatter)

    def add_args(self):
        group = self.parser.add_argument_group('arguments')
        for item in self.ARGS:
            group.add_argument(*item['keys'], **item['properties'])

    def run(self):
        args = self.parser.parse_args()
        Main().main(
            aligned_faa=args.aligned_faa,
            prefix_1=args.prefix_1,
            prefix_2=args.prefix_2,
            fraction_cutoff=args.fraction_cutoff
        )


class Main:

    CATEGORY_1 = 'CATEGORY_1'
    CATEGORY_2 = 'CATEGORY_2'
    OUTPUT_CSV = f'{__file__[:-3]}.csv'
    OUTPUT_PNG = f'{__file__[:-3]}.png'

    aligned_faa: str
    prefix_1: str
    prefix_2: str
    fraction_cutoff: float

    header_prefix_to_category: Dict[str, str]
    residue_data_df: pd.DataFrame
    position_score_df: pd.DataFrame

    def main(
            self,
            aligned_faa: str,
            prefix_1: str,
            prefix_2: str,
            fraction_cutoff: float):

        self.aligned_faa = aligned_faa
        self.prefix_1 = prefix_1
        self.prefix_2 = prefix_2
        self.fraction_cutoff = fraction_cutoff

        self.set_header_prefix_to_category()
        self.compute_residue_data_df()
        self.compute_position_score_df()
        self.plot_score()

    def set_header_prefix_to_category(self):
        self.header_prefix_to_category = {
            self.prefix_1: self.CATEGORY_1,
            self.prefix_2: self.CATEGORY_2,
        }

    def compute_residue_data_df(self):

        data = {
            'category': [],
            'fasta_header': [],
            'position': [],
            'aminoacid': [],
        }

        with FastaParser(self.aligned_faa) as parser:
            for head, seq in parser:
                for pos, aa in enumerate(seq):

                    category = self.__get_category(header=head)

                    data['category'].append(category)
                    data['fasta_header'].append(head)
                    data['position'].append(pos+1)  # 0 to 1-based
                    data['aminoacid'].append(aa)

        self.residue_data_df = pd.DataFrame(data=data)

    def __get_category(self, header: str) -> Optional[str]:
        for key, val in self.header_prefix_to_category.items():
            if header.startswith(key):
                return val

    def compute_position_score_df(self):

        data = {
            'position': [],
            'fraction_present': [],
            'differential_conservation_score': [],
        }

        df = self.residue_data_df
        positions = sorted(df['position'].unique())

        for pos in positions:

            all_aa = df.loc[df['position'] == pos, 'aminoacid']
            fraction = fraction_present(aminoacids=all_aa)
            if fraction < self.fraction_cutoff:
                continue

            aminoacids_1 = df.aminoacid[(df['position'] == pos) & (df['category'] == self.CATEGORY_1)]
            aminoacids_2 = df.aminoacid[(df['position'] == pos) & (df['category'] == self.CATEGORY_2)]

            score = DifferentialConservationScore().main(
                aminoacids1=aminoacids_1,
                aminoacids2=aminoacids_2)

            data['position'].append(pos)
            data['fraction_present'].append(fraction)
            data['differential_conservation_score'].append(score)

        self.position_score_df = pd.DataFrame(data=data)
        self.position_score_df.to_csv(self.OUTPUT_CSV, index=False)

    def plot_score(self):

        df = self.position_score_df

        plt.figure(figsize=(6, 6))
        plt.plot(
            df['position'],
            df['differential_conservation_score'],
            marker='o',
            markersize=3,
            linestyle='None',
            markeredgewidth=0,
            markeredgecolor='black'
        )
        plt.xlabel('Position')
        plt.ylabel('Differential conservation score')
        plt.savefig(self.OUTPUT_PNG, dpi=600)
        plt.close()


class FastaParser:

    def __init__(self, file: str):
        self.__fasta = open(file, 'r')

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
        return

    def __iter__(self):
        self.__fasta.seek(0)
        return self

    def __next__(self):
        r = self.next()
        if r:
            return r
        else:  # r is None
            raise StopIteration

    def next(self) -> Optional[Tuple[str, str]]:
        """
        Returns the next read of the fasta file
        If it reaches the end of the file, return None
        """
        header = self.__fasta.readline().rstrip()[1:]
        if header == '':
            return None

        seq = ''
        while True:
            pos = self.__fasta.tell()
            line = self.__fasta.readline().rstrip()
            if line.startswith('>'):
                self.__fasta.seek(pos)
                return header, seq
            if line == '':
                return header, seq
            seq = seq + line

    def close(self):
        self.__fasta.close()


class DifferentialConservationScore:

    # link to BLOSUM80_TEXT: https://www.ncbi.nlm.nih.gov/IEB/ToolBox/C_DOC/lxr/source/data/BLOSUM80#L27
    BLOSUM80_TEXT = '''\
id,A,R,N,D,C,Q,E,G,H,I,L,K,M,F,P,S,T,W,Y,V,B,J,Z,X,*
A,5,-2,-2,-2,-1,-1,-1,0,-2,-2,-2,-1,-1,-3,-1,1,0,-3,-2,0,-2,-2,-1,-1,-6
R,-2,6,-1,-2,-4,1,-1,-3,0,-3,-3,2,-2,-4,-2,-1,-1,-4,-3,-3,-1,-3,0,-1,-6
N,-2,-1,6,1,-3,0,-1,-1,0,-4,-4,0,-3,-4,-3,0,0,-4,-3,-4,5,-4,0,-1,-6
D,-2,-2,1,6,-4,-1,1,-2,-2,-4,-5,-1,-4,-4,-2,-1,-1,-6,-4,-4,5,-5,1,-1,-6
C,-1,-4,-3,-4,9,-4,-5,-4,-4,-2,-2,-4,-2,-3,-4,-2,-1,-3,-3,-1,-4,-2,-4,-1,-6
Q,-1,1,0,-1,-4,6,2,-2,1,-3,-3,1,0,-4,-2,0,-1,-3,-2,-3,0,-3,4,-1,-6
E,-1,-1,-1,1,-5,2,6,-3,0,-4,-4,1,-2,-4,-2,0,-1,-4,-3,-3,1,-4,5,-1,-6
G,0,-3,-1,-2,-4,-2,-3,6,-3,-5,-4,-2,-4,-4,-3,-1,-2,-4,-4,-4,-1,-5,-3,-1,-6
H,-2,0,0,-2,-4,1,0,-3,8,-4,-3,-1,-2,-2,-3,-1,-2,-3,2,-4,-1,-4,0,-1,-6
I,-2,-3,-4,-4,-2,-3,-4,-5,-4,5,1,-3,1,-1,-4,-3,-1,-3,-2,3,-4,3,-4,-1,-6
L,-2,-3,-4,-5,-2,-3,-4,-4,-3,1,4,-3,2,0,-3,-3,-2,-2,-2,1,-4,3,-3,-1,-6
K,-1,2,0,-1,-4,1,1,-2,-1,-3,-3,5,-2,-4,-1,-1,-1,-4,-3,-3,-1,-3,1,-1,-6
M,-1,-2,-3,-4,-2,0,-2,-4,-2,1,2,-2,6,0,-3,-2,-1,-2,-2,1,-3,2,-1,-1,-6
F,-3,-4,-4,-4,-3,-4,-4,-4,-2,-1,0,-4,0,6,-4,-3,-2,0,3,-1,-4,0,-4,-1,-6
P,-1,-2,-3,-2,-4,-2,-2,-3,-3,-4,-3,-1,-3,-4,8,-1,-2,-5,-4,-3,-2,-4,-2,-1,-6
S,1,-1,0,-1,-2,0,0,-1,-1,-3,-3,-1,-2,-3,-1,5,1,-4,-2,-2,0,-3,0,-1,-6
T,0,-1,0,-1,-1,-1,-1,-2,-2,-1,-2,-1,-1,-2,-2,1,5,-4,-2,0,-1,-1,-1,-1,-6
W,-3,-4,-4,-6,-3,-3,-4,-4,-3,-3,-2,-4,-2,0,-5,-4,-4,11,2,-3,-5,-3,-3,-1,-6
Y,-2,-3,-3,-4,-3,-2,-3,-4,2,-2,-2,-3,-2,3,-4,-2,-2,2,7,-2,-3,-2,-3,-1,-6
V,0,-3,-4,-4,-1,-3,-3,-4,-4,3,1,-3,1,-1,-3,-2,0,-3,-2,4,-4,2,-3,-1,-6
B,-2,-1,5,5,-4,0,1,-1,-1,-4,-4,-1,-3,-4,-2,0,-1,-5,-3,-4,5,-4,0,-1,-6
J,-2,-3,-4,-5,-2,-3,-4,-5,-4,3,3,-3,2,0,-4,-3,-1,-3,-2,2,-4,3,-3,-1,-6
Z,-1,0,0,1,-4,4,5,-3,0,-4,-3,1,-1,-4,-2,0,-1,-3,-3,-3,0,-3,5,-1,-6
X,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-6
*,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,1
'''
    BLOSUM = pd.read_csv(StringIO(BLOSUM80_TEXT), index_col='id')

    aas_1: List[str]
    aas_2: List[str]

    def main(
            self,
            aminoacids1: List[str],
            aminoacids2: List[str]) -> float:

        self.aas_1 = [a for a in aminoacids1 if a != '-']
        self.aas_2 = [a for a in aminoacids2 if a != '-']

        a = self.get_intra_group_similarity()
        b = self.get_inter_group_similarity()

        return a - b

    def get_intra_group_similarity(self) -> float:

        scores = []

        for aas in [self.aas_1, self.aas_2]:

            c = 0  # count
            s = 0  # sum
            for a1, a2, in combinations(aas, 2):
                c += 1
                s += self.BLOSUM[a1][a2]

            scores.append(s / c)

        return sum(scores) / len(scores)

    def get_inter_group_similarity(self) -> float:
        c = 0  # count
        s = 0  # sum
        for a1 in self.aas_1:
            for a2 in self.aas_2:
                c += 1
                s += self.BLOSUM[a1][a2]
        return s / c


def fraction_present(aminoacids: List[str]) -> float:
    c = 0
    for a in aminoacids:
        if a != '-':
            c += 1
    return c / len(aminoacids)


if __name__ == '__main__':
    EntryPoint().main()
    # python differential_conservation_score.py -f ./differential_conservation_score_test.faa -1 CONTROL -2 CASE
